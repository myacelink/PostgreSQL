◼︎ 플래너 메소드 구성
이러한 구성 매개 변수는 쿼리 최적화 프로그램이 선택한 쿼리 계획에 영향을주는 조잡한 방법을 제공합니다. 특정 쿼리에 대해 옵티마이 저가 선택한 기본 계획이 최적이 아닌 경우 임시 솔루션은 이러한 구성 매개 변수중 하나를 사용하여 옵티마이저가 다른 계획을 선택하도록하는 것입니다. 
옵티마이저가 선택한 계획의 품질을 개선하는 더 좋은 방법에는 플래너 비용 상수 조정 (섹션 19.7.2 참조), 수동으로 ANALYZE 실행, default_statistics_target 구성 매개 변수의 값 증가, ALTER TABLE SET STATISTICS를 사용하여 특정 열에 대해 수집된 통계량 증가가 포함됩니다. 
섹션 19.7.2 : https://www.postgresql.org/docs/12/runtime-config-query.html#RUNTIME-CONFIG-QUERY-CONSTANTS

enable_bitmapscan (boolean)
쿼리 플래너의 비트 맵 스캔 계획 유형 사용을 활성화하거나 비활성화합니다. 기본값은 on입니다.

enable_gathermerge (boolean)
쿼리 플래너의 수집 병합 계획 유형 사용을 활성화하거나 비활성화합니다. 기본값은 on입니다.

enable_hashagg (boolean)
쿼리 플래너의 해시 집계 계획 유형 사용을 활성화하거나 비활성화합니다. 기본값은 on입니다.

enable_hashjoin (boolean)
쿼리 플래너의 해시 조인 계획 유형 사용을 활성화하거나 비활성화합니다. 기본값은 on입니다.

enable_indexscan (boolean)
쿼리 플래너의 인덱스 스캔 계획 유형 사용을 활성화하거나 비활성화합니다. 기본값은 on입니다.

enable_indexonlyscan (boolean)
쿼리 플래너의 인덱스 전용 스캔 계획 유형 사용을 활성화 또는 비활성화합니다 (섹션 11.9 참조). 기본값은 on입니다.

enable_material (boolean)
쿼리 플래너의 구체화 사용을 활성화 또는 비활성화합니다. 구체화를 완전히 억제하는 것은 불가능하지만 이 변수를 끄면 플래너가 정확성을 위해 필요한 경우를 제외하고 구체화 노드를 삽입하지 못합니다. 기본값은 on입니다.

enable_mergejoin (boolean)
쿼리 플래너의 병합 조인 계획 유형 사용을 활성화하거나 비활성화합니다. 기본값은 on입니다.

enable_nestloop (boolean)
쿼리 플래너의 중첩 루프 조인 계획 사용을 활성화하거나 비활성화합니다. 중첩 루프 조인을 완전히 억제하는 것은 불가능하지만 이 변수를 끄면 사용 가능한 다른 방법이 있는 경우 플래너가 하나를 사용하지 못하게됩니다. 기본값은 on입니다.

enable_parallel_append (boolean)
쿼리 플래너의 병렬 인식 추가 계획 유형 사용을 활성화하거나 비활성화합니다. 기본값은 on입니다.

enable_parallel_hash (boolean)
쿼리 플래너가 병렬 해시가 있는 해시 조인 계획 유형을 사용하거나 사용하지 않도록 설정합니다. 해시 조인 계획도 활성화되지 않은 경우 효과가 없습니다. 기본값은 on입니다.

enable_partition_pruning (boolean)
쿼리 계획에서 분할된 테이블의 파티션을 제거하는 쿼리 플래너의 기능을 활성화하거나 비활성화합니다. 이는 또한 쿼리 실행 중에 쿼리 실행자가 파티션을 제거(무시)할 수 있도록 하는 쿼리 계획을 생성하는 플래너의 기능을 제어합니다. 기본값은 on입니다. 자세한 내용은 섹션 5.11.4를 참조하십시오.
Section 5.11.4 : https://www.postgresql.org/docs/12/ddl-partitioning.html#DDL-PARTITION-PRUNING

enable_partitionwise_join (boolean)
쿼리 플래너의 분할 조인 사용을 활성화하거나 비활성화합니다. 이렇게하면 일치하는 파티션을 조인하여 분할된 테이블 간의 조인을 수행할 수 있습니다. 파티션별 조인은 현재 조인 조건에 모든 파티션 키가 포함되어 있는 경우에만 적용됩니다.이 키는 동일한 데이터 유형이어야 하며 정확히 일치하는 하위 파티션 세트가 있어야합니다. 분할 조인 계획은 계획 중에 훨씬 더 많은 CPU 시간과 메모리를 사용할 수 있으므로 기본값은 해제입니다.

enable_partitionwise_aggregate (boolean)
쿼리 플래너가 파티션별 그룹화 또는 집계를 사용하거나 사용하지 않도록 설정하여 각 파티션에 대해 별도로 수행되는 파티션된 테이블에 대한 그룹화 또는 집계를 허용합니다. GROUP BY 절에 파티션 키가 포함되지 않은 경우 부분 집계만 파티션별로 수행할 수 있으며 나중에 마무리를 수행해야합니다. 파티션별 그룹화 또는 집계는 계획 중에 훨씬 더 많은 CPU 시간과 메모리를 사용할 수 있으므로 기본값은 해제입니다.

enable_seqscan (boolean)
쿼리 플래너의 순차 스캔 계획 유형 사용을 활성화하거나 비활성화합니다. 순차 스캔을 완전히 억제하는 것은 불가능하지만 이 변수를 끄면 사용 가능한 다른 방법이 있는 경우 플래너가 하나를 사용하지 못하게됩니다. 기본값은 on입니다.

enable_sort (boolean)
쿼리 플래너의 명시적 정렬 단계 사용을 활성화하거나 비활성화합니다. 명시적 정렬을 완전히 억제하는 것은 불가능하지만이 변수를 끄면 사용 가능한 다른 방법이 있는 경우 플래너가 하나를 사용하지 못하게됩니다. 기본값은 on입니다.

enable_tidscan (boolean)
쿼리 플래너의 TID 스캔 계획 유형 사용을 활성화하거나 비활성화합니다. 기본값은 on입니다.

◼︎ 플래너 비용 상수
이 섹션에서 설명하는 비용 변수는 임의의 척도로 측정됩니다. 상대적인 값만 중요하므로 동일한 요소로 모두 확장 또는 축소해도 플래너의 선택에 변화가 없습니다. 기본적으로 이러한 비용 변수는 순차적 페이지 가져 오기 비용을 기반으로합니다. 즉, seq_page_cost는 일반적으로 1.0으로 설정되고 다른 비용 변수는 이를 참조하여 설정됩니다. 그러나 원하는 경우 특정 시스템의 실제 실행 시간 (밀리 초)과 같이 다른 척도를 사용할 수 있습니다.

참고
불행히도 비용 변수에 대한 이상적인 값을 결정하기 위한 잘 정의된 방법이 없습니다. 특정 설치가 수신할 전체 쿼리 조합에 대한 평균으로 가장 잘 처리됩니다. 이것은 단지 몇 가지 실험을 기반으로 그것들을 변경하는 것은 매우 위험하다는 것을 의미합니다.

seq_page_cost (floating point)
일련의 순차적 페치의 일부인 디스크 페이지 페치 비용에 대한 플래너의 추정치를 설정합니다. 기본값은 1.0입니다. 같은 이름의 테이블 스페이스 매개 변수를 설정하여 특정 테이블 스페이스의 테이블 및 인덱스에 대해 이 값을 재정의 할 수 있습니다 (ALTER TABLESPACE 참조).

random_page_cost (floating point)
순차적으로 페치되지 않은 디스크 페이지의 비용에 대한 플래너의 추정치를 설정합니다. 기본값은 4.0입니다. 같은 이름의 테이블 스페이스 매개 변수를 설정하여 특정 테이블 스페이스의 테이블 및 인덱스에 대해이 값을 재정의 할 수 있습니다 (ALTER TABLESPACE 참조).
seq_page_cost에 상대적으로 이 값을 줄이면 시스템이 인덱스 스캔을 선호하게됩니다. 값을 높이면 인덱스 스캔이 상대적으로 더 비싸 보이게됩니다. 두 값을 함께 높이거나 낮춰 CPU 비용과 관련된 디스크 I/O 비용의 중요성을 변경할 수 있습니다. 이는 다음 매개 변수로 설명됩니다.
기계적 디스크 스토리지에 대한 임의 액세스는 일반적으로 순차 액세스의 4배보다 훨씬 비쌉니다. 그러나 인덱싱된 읽기와 같은 디스크에 대한 대부분의 임의 액세스가 캐시에 있다고 가정하므로 더 낮은 기본값 (4.0)이 사용됩니다. 기본값은 임의 읽기의 90%가 캐시될 것으로 예상하면서 임의 액세스를 순차보다 40배 느리게 모델링하는 것으로 생각할 수 있습니다.
90% 캐시 비율이 워크로드에 대한 잘못된 가정이라고 생각되면 random_page_cost를 늘려 임의 스토리지 읽기의 실제 비용을 더 잘 반영할 수 있습니다. 따라서 데이터베이스가 총 서버 메모리보다 작은 경우와 같이 데이터가 완전히 캐시에 있을 가능성이 있는 경우 random_page_cost를 줄이는 것이 적절할 수 있습니다. 순차에 비해 무작위 읽기 비용이 낮은 스토리지 (예 : 솔리드 스테이트 드라이브)는 random_page_cost 값(예 : 1.1)을 더 낮게 모델링하는 것이 더 좋습니다.

Tip
시스템에서 random_page_cost를 seq_page_cost 미만으로 설정할 수 있지만 그렇게하는 것은 물리적으로 합리적이지 않습니다. 그러나 데이터베이스가 RAM에 완전히 캐시된 경우 동일하게 설정하는 것이 합리적입니다. 이 경우 순서를 벗어난 페이지를 건드려도 불이익이 없기 때문입니다. 또한 캐시가 많은 데이터베이스에서는 이미 RAM에 있는 페이지를 가져 오는데 드는 비용이 평소보다 훨씬 적기 때문에 CPU 매개 변수에 비해 두 값을 모두 낮춰야합니다.

cpu_tuple_cost (floating point)
쿼리 중에 각 행을 처리하는데 드는 계획자의 예상 비용을 설정합니다. 기본값은 0.01입니다.

cpu_index_tuple_cost (floating point)
인덱스 스캔 중에 각 인덱스 항목을 처리하는 데 드는 계획 자의 예상 비용을 설정합니다. 기본값은 0.005입니다.

cpu_operator_cost (floating point)
쿼리 중에 실행되는 각 연산자 또는 함수를 처리하는데 드는 계획자의 예상 비용을 설정합니다. 기본값은 0.0025입니다.

parallel_setup_cost (floating point)
병렬 작업자 프로세스를 시작하는 데 드는 계획 자의 예상 비용을 설정합니다. 기본값은 1000입니다.

parallel_tuple_cost (floating point)
하나의 튜플을 병렬 작업자 프로세스에서 다른 프로세스로 전송하는 비용에 대한 planner의 추정치를 설정합니다. 기본값은 0.1입니다.

min_parallel_table_scan_size (integer)
병렬 스캔을 고려하기 위해 스캔해야하는 테이블 데이터의 최소량을 설정합니다. 병렬 순차 스캔의 경우 스캔되는 테이블 데이터의 양은 항상 테이블의 크기와 동일하지만 인덱스를 사용하는 경우 스캔되는 테이블 데이터의 양은 일반적으로 더 적습니다. 이 값이 단위없이 지정되면 블록 (BLCKSZ 바이트, 일반적으로 8kB)으로 간주됩니다. 기본값은 8MB (8MB)입니다.

min_parallel_index_scan_size (integer)
병렬 스캔을 고려하기 위해 스캔해야하는 인덱스 데이터의 최소량을 설정합니다. 병렬 인덱스 스캔은 일반적으로 전체 인덱스를 건드리지 않습니다. 플래너가 실제로 관련 스캔에 의해 터치될 것이라고 생각하는 페이지 수입니다. 이 값이 단위없이 지정되면 블록 (BLCKSZ 바이트, 일반적으로 8kB)으로 간주됩니다. 기본값은 512KB (512kB)입니다.

effective_cache_size (integer)
단일 쿼리에 사용할 수 있는 디스크 캐시의 유효 크기에 대한 플래너의 가정을 설정합니다. 이것은 인덱스 사용 비용 추정치에 반영됩니다. 값이 높을수록 인덱스 스캔이 더 많이 사용되고, 값이 낮을수록 순차 스캔이 더 많이 사용됩니다. 이 매개 변수를 설정할 때 PostgreSQL의 공유 버퍼와 PostgreSQL 데이터 파일에 사용될 커널의 디스크 캐시 부분을 모두 고려해야하지만 일부 데이터는 두 위치에 모두 존재할 수 있습니다. 또한 사용 가능한 공간을 공유해야하므로 서로 다른 테이블에서 예상되는 동시 쿼리 수를 고려합니다. 이 매개 변수는 PostgreSQL에 의해 할당된 공유 메모리의 크기에 영향을 미치지 않으며 커널 디스크 캐시를 예약하지도 않습니다. 추정 목적으로 만 사용됩니다. 또한 시스템은 쿼리 사이에 데이터가 디스크 캐시에 남아 있다고 가정하지 않습니다. 이 값이 단위없이 지정되면 블록 (BLCKSZ 바이트, 일반적으로 8kB)으로 간주됩니다. 기본값은 4GB (4GB)입니다. (BLCKSZ가 8kB가 아닌 경우 기본값은 이에 비례하여 조정됩니다.)

jit_above_cost (floating point)
활성화 된 경우 JIT 컴파일이 활성화되는 쿼리 비용을 설정합니다 (31 장 참조). JIT를 수행하면 계획 시간이 소요되지만 쿼리 실행을 가속화 할 수 있습니다. -1로 설정하면 JIT 컴파일이 비활성화됩니다. 기본값은 100000입니다.
Chapter 31 : https://www.postgresql.org/docs/12/jit.html

jit_inline_above_cost (floating point)
JIT 컴파일이 함수 및 연산자를 인라인하려고 시도하는 쿼리 비용을 설정합니다. 인라이닝은 계획 시간을 추가하지만 실행 속도를 향상시킬 수 있습니다. 이 값을 jit_above_cost보다 작게 설정하는 것은 의미가 없습니다. -1로 설정하면 인라인이 비활성화됩니다. 기본값은 500000입니다.

jit_optimize_above_cost (floating point)
JIT 컴파일이 비용이 많이 드는 최적화를 적용하는 쿼리 비용을 설정합니다. 이러한 최적화는 계획 시간을 추가하지만 실행 속도를 향상시킬 수 있습니다. 이 값을 jit_above_cost 미만으로 설정하는 것은 의미가 없으며 jit_inline_above_cost 이상으로 설정하는 것은 유익하지 않을 것입니다. 이 값을 -1로 설정하면 비용이 많이 드는 최적화가 비활성화됩니다. 기본값은 500000입니다.

◼︎ Genetic 쿼리 최적화
GEQO (genetic query optimizer)는 휴리스틱 검색을 사용하여 쿼리 계획을 수행하는 알고리즘입니다. 이렇게하면 복잡한 쿼리 (많은 관계를 결합하는 쿼리)에 대한 계획 시간이 단축되고, 때로는 일반 전체 검색 알고리즘에 의해 발견되는 계획보다 열등한 계획을 생성합니다. 자세한 내용은 59 장을 참조하십시오.
Chapter 59 : https://www.postgresql.org/docs/12/geqo.html

geqo (boolean)
유전자 쿼리 최적화를 활성화하거나 비활성화합니다. 이것은 기본적으로 켜져 있습니다. 일반적으로 프로덕션에서 끄지 않는 것이 가장 좋습니다. geqo_threshold 변수는 GEQO를보다 세부적으로 제어합니다.

geqo_threshold (integer)
유전 쿼리 최적화를 사용하여 최소한의 개수 이상의 FROM 항목이 포함된 쿼리를 계획합니다. (FULL OUTER JOIN 구문은 하나의 FROM 항목으로만 계산됩니다.) 기본값은 12입니다. 간단한 쿼리의 경우 일반적으로 일반 전체 검색 플래너를 사용하는 것이 가장 좋지만 테이블이 많은 쿼리의 경우 전체 검색이 너무 오래 걸립니다. , 종종 차선책을 실행하는데 따른 패널티보다 깁니다. 따라서 쿼리 크기에 대한 임계 값은 GEQO 사용을 관리하는 편리한 방법입니다.

geqo_effort (integer)
여야 합니다. 기본값은 5입니다. 값이 클수록 쿼리 계획에 소요되는 시간이 늘어나지만 효율적인 쿼리 계획이 선택될 가능성도 높아집니다.

geqo_effort는 실제로 직접 아무것도하지 않습니다. GEQO 동작에 영향을 미치는 다른 변수에 대한 기본값을 계산하는 데만 사용됩니다 (아래 설명). 원하는 경우 다른 매개 변수를 대신 수동으로 설정할 수 있습니다.

geqo_pool_size (integer)
GEQO에서 사용하는 풀 크기, 즉 유전 집단의 개인 수를 제어합니다. 2개 이상이어야 하며 유용한 값은 일반적으로 100 ~ 1000입니다. 0(기본 설정)으로 설정되면 geqo_effort 및 쿼리의 테이블 수를 기반으로 적절한 값이 선택됩니다.

geqo_generations (integer)
GEQO에서 사용하는 생성 수, 즉 알고리즘의 반복 수를 제어합니다. 하나 이상이어야하며 유용한 값은 풀 크기와 동일한 범위에 있습니다. 0(기본 설정)으로 설정되면 geqo_pool_size에 따라 적절한 값이 선택됩니다.

geqo_selection_bias (floating point)
GEQO에서 사용하는 선택 편향을 제어합니다. 선택 편향은 모집단 내의 선택적 압력입니다. 값은 1.50에서 2.00까지 가능합니다. 후자가 기본값입니다.

geqo_seed (floating point)
조인 순서 검색 공간을 통해 임의 경로를 선택하기 위해 GEQO에서 사용하는 난수 생성기의 초기 값을 제어합니다. 값의 범위는 0 (기본값)에서 1까지입니다. 값을 변경하면 탐색된 조인 경로 집합이 변경되고 더 나은 또는 더 나쁜 최상의 경로를 찾을 수 있습니다.

◼︎ 다른 플래너 옵션
default_statistics_target (integer)
ALTER TABLE SET STATISTICS를 통해 컬럼 특정 대상이 설정되지 않은 테이블 컬럼에 대한 기본 통계 대상을 설정합니다. 값이 클수록 ANALYZE를 수행하는데 필요한 시간이 늘어나지만 플래너의 추정치 품질이 향상될 수 있습니다. 기본값은 100입니다. PostgreSQL 쿼리 플래너의 통계 사용에 대한 자세한 내용은 14.2 절을 참조하십시오.
14.2 : https://www.postgresql.org/docs/12/planner-stats.html

constraint_exclusion (enum)
쿼리 플래너의 테이블 제약 조건 사용을 제어하여 쿼리를 최적화합니다. constraint_exclusion의 허용된 값은 on(모든 테이블에 대한 제약 조건 검사), off(제약 조건 검사 안 함) 및 partition (상속 하위 테이블 및 UNION ALL 하위 쿼리에 대해서만 제약 조건 검사)입니다. 파티션이 기본 설정입니다. 성능을 향상시키기 위해 종종 전통적인 상속 트리와 함께 사용됩니다.

이 매개 변수가 특정 테이블에 대해 허용하는 경우 플래너는 쿼리 조건을 테이블의 CHECK 제약 조건과 비교하고 조건이 제약 조건과 모순되는 테이블 스캔을 생략합니다. 예를 들면 :
CREATE TABLE parent(key integer, ...);
CREATE TABLE child1000(check (key between 1000 and 1999)) INHERITS(parent);
CREATE TABLE child2000(check (key between 2000 and 2999)) INHERITS(parent);
...
SELECT * FROM parent WHERE key = 2400;
제약 제외를 활성화하면이 SELECT는 child1000을 전혀 검색하지 않으므로 성능이 향상됩니다.

현재 제약 제외는 상속 트리를 통해 테이블 분할을 구현하는데 자주 사용되는 경우에만 기본적으로 활성화됩니다. 모든 테이블에 대해 이 기능을 설정하면 단순 쿼리에서 상당히 눈에 띄는 추가 계획 오버 헤드가 발생하며 대부분의 경우 단순 쿼리에는 이점이 없습니다. 기존 상속을 사용하여 분할된 테이블이 없는 경우 완전히 해제하는 것이 좋습니다. (파티션을 나눈 테이블에 해당하는 기능은 별도의 매개 변수 인 enable_partition_pruning에 의해 제어됩니다.)

제약 제외를 사용하여 분할을 구현하는 방법에 대한 자세한 내용은 섹션 5.11.5를 참조하십시오.
5.11.5 : https://www.postgresql.org/docs/12/ddl-partitioning.html#DDL-PARTITIONING-CONSTRAINT-EXCLUSION

cursor_tuple_fraction (floating point)
검색될 커서 행의 비율에 대한 플래너의 추정치를 설정합니다. 기본값은 0.1입니다. 이 설정의 값이 작을수록 플래너는 커서에 대해 "빠른 시작"계획을 사용하는것으로 편향되어 처음 몇개의 행을 빠르게 검색하지만 모든 행을 가져 오는데 시간이 오래 걸릴 수 있습니다. 값이 클수록 총 예상 시간이 더 강조됩니다. 1.0의 최대 설정에서 커서는 첫 번째 행이 전달될 수 있는 시간이 아니라 총 예상 시간만 고려하여 일반 쿼리와 똑같이 계획됩니다.

from_collapse_limit (integer)
플래너는 결과 FROM 목록에 이보다 많은 항목이 없을 경우 하위 쿼리를 상위 쿼리로 병합합니다. 값이 작을수록 계획 시간이 단축되지만 쿼리 계획이 나빠질 수 있습니다. 기본값은 8입니다. 자세한 내용은 섹션 14.3을 참조합니다.
Section 14.3. : https://www.postgresql.org/docs/12/explicit-joins.html

이 값을 geqo_threshold 이상으로 설정하면 GEQO 플래너 사용이 트리거되어 최적이 아닌 계획이 생성될 수 있습니다. 19.7.3 절을 참조하십시오.
19.7.3 : https://www.postgresql.org/docs/12/runtime-config-query.html#RUNTIME-CONFIG-QUERY-GEQO

jit (boolean)
가능한 경우 PostgreSQL에서 JIT 컴파일을 사용할 수 있는지 여부를 결정합니다 (31 장 참조). 기본값은 on입니다.
Chapter 31 : https://www.postgresql.org/docs/12/jit.html

join_collapse_limit (integer)
플래너는 이 개수 이하의 항목 목록이 생성될 때마다 명시적 JOIN 구문 (FULL JOIN 제외)을 FROM 항목 목록으로 다시 작성합니다. 값이 작을수록 계획 시간이 단축되지만 쿼리 계획이 나빠질 수 있습니다.

기본적으로 이 변수는 대부분의 용도에 적합한 from_collapse_limit와 동일하게 설정됩니다. 1로 설정하면 명시적 JOIN의 순서가 변경되지 않습니다. 따라서 쿼리에 지정된 명시적 조인 순서는 관계가 조인되는 실제 순서가 됩니다. 쿼리 플래너가 항상 최적의 조인 순서를 선택하는 것은 아니기 때문에 고급 사용자는 이 변수를 일시적으로 1로 설정한 다음 원하는 조인 순서를 명시적으로 지정할 수 있습니다. 자세한 내용은 섹션 14.3을 참조하십시오.
Section 14.3. : https://www.postgresql.org/docs/12/explicit-joins.html
Section 19.7.3 : https://www.postgresql.org/docs/12/runtime-config-query.html#RUNTIME-CONFIG-QUERY-GEQO

이 값을 geqo_threshold 이상으로 설정하면 GEQO 플래너 사용이 트리거되어 최적이 아닌 계획이 생성될 수 있습니다. 19.7.3 절을 참조하십시오.

parallel_leader_participation (boolean)
리더 프로세스가 작업자 프로세스를 기다리는 대신 Gather 및 Gather Merge 노드에서 쿼리 계획을 실행할 수 있도록 합니다. 기본값은 on입니다. 이 값을 off로 설정하면 리더가 튜플을 충분히 빠르게 읽지 못하기 때문에 작업자가 차단될 가능성이 줄어들지만, 리더 프로세스는 첫 번째 튜플이 생성되기 전에 작업자 프로세스가 시작될 때까지 기다려야합니다. 리더가 성과를 돕거나 방해 할 수 있는 요소는 계획 유형, 작업자 수 및 쿼리 기간에 따라 다릅니다.

force_parallel_mode (enum)
성능 이점이 예상되지 않는 경우에도 테스트 목적으로 병렬 쿼리를 사용할 수 있습니다. force_parallel_mode의 허용된 값은 off(성능 개선이 예상되는 경우에만 병렬 모드를 사용), on(안전하다고 생각되는 모든 쿼리에 대해 병렬 쿼리를 적용) 및 regress(아래 설명과 같이 추가적인 동작 변경과 함께)입니다.

보다 구체적으로 이 값을 on으로 설정하면 안전한 것으로 보이는 쿼리 계획의 맨 위에 Gather 노드가 추가되어 쿼리가 병렬 작업자 내부에서 실행됩니다. 병렬 작업자를 사용할 수 없거나 사용할 수 없는 경우에도 병렬 쿼리 컨텍스트에서 금지되는 하위 트랜잭션 시작과 같은 작업은 플래너가 쿼리가 실패할 것이라고 생각하지 않는한 금지됩니다. 이 옵션을 설정할 때 실패 또는 예기치 않은 결과가 발생하면 쿼리에서 사용하는 일부 함수를 PARALLEL UNSAFE (또는 가능하면 PARALLEL RESTRICTED)로 표시해야 할 수 있습니다.

이 값을 regress(회귀)로 설정하면 on으로 설정하는 것과 동일한 효과와 자동화된 회귀 테스트를 용이하게 하기위한 몇 가지 추가 효과가 있습니다. 일반적으로 병렬 작업자의 메시지에는 이를 나타내는 컨텍스트 줄이 포함되지만 회귀 설정은 이 줄을 억제하여 출력이 non-parallel 실행에서와 동일하도록 합니다. 또한 이 설정에 의해 계획에 추가된 Gather 노드는 EXPLAIN 출력에서 숨겨 지므로 출력이 이 설정이 해제된 경우 얻을 수 있는 것과 일치합니다.

plan_cache_mode (enum)
준비된 명령문 (예를 들어 PL / pgSQL에 의해 명시적으로 준비되거나 암시적으로 생성됨)은 사용자 정의 또는 일반 계획을 사용하여 실행할 수 있습니다. 사용자 지정 계획은 특정 매개 변수 값 집합을 사용하여 각 실행에 대해 새로 만들어지는 반면 일반 계획은 매개 변수 값에 의존하지 않고 실행 전체에서 다시 사용할 수 있습니다. 따라서 일반 계획을 사용하면 계획 시간이 절약되지만 이상적인 계획이 매개 변수 값에 크게 의존하는 경우 일반 계획이 비효율적 일 수 있습니다. 이러한 옵션 사이의 선택은 일반적으로 자동으로 이루어 지지만 plan_cache_mode로 재정의 할 수 있습니다. 허용되는 값은 auto (기본값), force_custom_plan 및 force_generic_plan입니다. 이 설정은 캐시된 계획이 준비될 때가 아니라 실행될 때 고려됩니다. 자세한 내용은 PREPARE를 참조하십시오.
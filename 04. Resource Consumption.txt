◼︎ Memory
shared_buffers (integer)
데이터베이스 서버가 공유 메모리 버퍼에 사용하는 메모리 양을 설정합니다. 기본값은 일반적으로 128MB (128MB)이지만
커널 설정이 이를 지원하지 않는 경우 더 적을 수 있습니다 (initdb 중에 결정됨).
이 설정은 128KB 이상이어야 합니다. 그러나 좋은 성능을 위해서는 일반적으로 최소값보다 훨씬 높은 설정이 필요합니다.
이 값이 단위없이 지정되면 블록(BLCKSZ 바이트, 일반적으로 8kB)으로 간주됩니다. (BLCKSZ의 기본값이 아닌 값은 최소값을 변경합니다.)이 매개 변수는 서버 시작시에만 설정할 수 있습니다.

RAM이 1GB 이상인 전용 데이터베이스 서버가 있는 경우 shared_buffers의 적절한 시작 값은 시스템 메모리의 25 %입니다.
shared_buffers에 대한 더 큰 설정이 효과적인 일부 워크로드가 있지만 PostgreSQL도 운영 체제 캐시에 의존하기 때문에
shared_buffers에 RAM의 40 % 이상을 할당하는 것이 적은 양보다 더 잘 작동 할 가능성은 낮습니다.
shared_buffers에 대한 더 큰 설정은 일반적으로 더 오랜 기간에 걸쳐 많은 양의 새 데이터 또는 변경된 데이터를 쓰는 프로세스를 분산시키기 위해 max_wal_size의 상응하는 증가가 필요합니다.

RAM이 1GB 미만인 시스템에서는 운영 체제를 위한 적절한 공간을 남겨두기 위해 더 적은 비율의 RAM이 적합합니다.

huge_pages (enum)
주 공유 메모리 영역에 대해 대용량 페이지가 요청되는지 여부를 제어합니다. 유효한 값은 try(기본값), on 및 off입니다.
huge_pages를 try로 설정하면 서버는 거대한 페이지를 요청하지만 실패하면 기본값으로 돌아갑니다.
on으로 설정하면 방대한 페이지를 요청하지 못하면 서버가 시작되지 않습니다. 끄면 방대한 페이지가 요청되지 않습니다.
현재 이 설정은 Linux 및 Windows에서만 지원됩니다. 시도하도록 설정하면 다른 시스템에서 설정이 무시됩니다.
방대한 페이지를 사용하면 페이지 테이블이 작아지고 메모리 관리에 소비되는 CPU 시간이 줄어들어 성능이 향상됩니다.
Windows에서는 대형(huge) 페이지를 큰(large) 페이지라고 합니다. 이를 사용하려면 PostgreSQL을 실행하는 Windows 사용자 계정에 메모리의 페이지 잠금 사용자 권한을 할당해야 합니다.
Windows 그룹 정책 도구 (gpedit.msc)를 사용하여 메모리에서 페이지 잠금 사용자 권한을 할당할 수 있습니다.
Windows 서비스가 아닌 독립 실행형 프로세스로 명령 프롬프트에서 데이터베이스 서버를 시작하려면 명령 프롬프트를 관리자로 실행하거나 UAC (사용자 액세스 제어)를 비활성화 해야 합니다.
UAC가 활성화되면 일반 명령 프롬프트가 시작될 때 메모리의 사용자 권한 잠금 페이지를 취소합니다.
이 설정은 주 공유 메모리 영역에만 영향을 미칩니다.
Linux, FreeBSD 및 Illumos와 같은 운영 체제는 PostgreSQL의 명시적인 요청없이 일반 메모리 할당을 위해 자동으로
거대한 페이지 ("수퍼"페이지 또는 "대형"페이지라고도 함)를 사용할 수도 있습니다. Linux에서는 이를 "투명 거대한 페이지"(THP)라고 합니다.
이 기능은 일부 Linux 버전의 일부 사용자에게 PostgreSQL의 성능 저하를 유발하는 것으로 알려져 있으므로 현재는 사용을 권장하지 않습니다(명시 적으로 huge_pages를 사용하는 것과 달리).

temp_buffers (integer)
각 데이터베이스 세션 내에서 임시 버퍼에 사용되는 최대 메모리 양을 설정합니다. 임시 테이블에 대한 액세스에만 사용되는 세션 로컬 버퍼입니다.
이 값이 단위없이 지정되면 블록(BLCKSZ 바이트, 일반적으로 8kB)으로 간주됩니다. 기본값은 8MB (8MB)입니다.(BLCKSZ가 8kB가 아닌 경우 기본값은 이에 비례하여 조정됩니다.)
이 설정은 개별 세션 내에서 변경할 수 있지만 세션 내에서 임시 테이블을 처음 사용하기 전에만 변경할 수 있습니다. 값을 변경하려는 후속 시도는 해당 세션에 영향을 주지 않습니다.
세션은 temp_buffers가 제공하는 한계까지 필요에 따라 임시 버퍼를 할당합니다.
실제로 많은 임시 버퍼가 필요하지 않은 세션에서 큰 값을 설정하는 비용은 temp_buffers의 증분당 버퍼 설명자 또는 약 64바이트입니다.
그러나 버퍼가 실제로 사용되는 경우 추가 8192 바이트 (또는 일반적으로 BLCKSZ 바이트)가 사용됩니다.

max_prepared_transactions (integer)
준비된 트랜잭션을 사용하지 않으려면 이 매개 변수를 0으로 설정하여 준비된 트랜잭션을 실수로 생성하지 않도록 해야합니다.
(Prepare Transaction : https://www.postgresql.org/docs/12/sql-prepare-transaction.html)
준비된 트랜잭션을 사용하는 경우, 모든 세션이 준비된 트랜잭션을 보류할 수 있도록 max_prepared_transactions가 최소 max_connections이상이기를 원할 것입니다.
대기 서버를 실행할 때이 매개 변수를 마스터 서버와 같거나 더 높은 값으로 설정해야 합니다. 그렇지 않으면 대기 서버에서 쿼리가 허용되지 않습니다.

work_mem (integer)
임시 디스크 파일에 쓰기 전에 쿼리 작업 (예 : 정렬 또는 해시 테이블)에서 사용할 최대 메모리 양을 설정합니다.
이 값이 단위없이 지정되면 킬로바이트로 간주됩니다. 기본값은 4MB(4MB)입니다. 복잡한 쿼리의 경우 여러 정렬 또는 해시 작업이 병렬로 실행될 수 있습니다.
각 작업은 임시 파일에 데이터 쓰기를 시작하기 전에 이 값이 지정한만큼의 메모리를 사용할 수 있습니다. 또한 여러 실행 세션에서 이러한 작업을 동시에 수행할 수 있습니다.
따라서 사용된 총 메모리는 work_mem 값의 여러 배가 될 수 있습니다. 값을 선택할 때 이 사실을 염두에 두어야합니다.
정렬 작업은 ORDER BY, DISTINCT 및 병합 조인에 사용됩니다. 해시 테이블은 해시 조인, 해시 기반 집계 및 IN 하위 쿼리의 해시 기반 처리에 사용됩니다.

maintenance_work_mem (integer)
VACUUM, CREATE INDEX 및 ALTER TABLE ADD FOREIGN KEY와 같은 유지 관리 작업에서 사용할 최대 메모리 양을 지정합니다.
이 값이 단위없이 지정되면 킬로바이트로 간주됩니다. 기본값은 64MB(64MB)입니다.
이러한 작업중 하나만 데이터베이스 세션에서 한 번에 실행할 수 있고 설치시 일반적으로 여러 작업이 동시에 실행되지 않으므로
이 값을 work_mem보다 훨씬 크게 설정하는 것이 안전합니다. 설정이 클수록 데이터 정리 및 데이터베이스 덤프 복원 성능이 향상 될 수 있습니다.
autovacuum이 실행될 때 autovacuum_max_workers 배까지 이 메모리가 할당될 수 있으므로 기본값을 너무 높게 설정하지 않도록 주의하십시오.
autovacuum_work_mem을 별도로 설정하여 이를 제어하는 것이 유용 할 수 있습니다.

autovacuum_work_mem (integer)
각 autovacuum 작업자 프로세스에서 사용할 최대 메모리 양을 지정합니다. 이 값이 단위없이 지정되면 킬로바이트로 간주됩니다.
기본값은 -1이며, 대신 maintenance_work_mem 값을 사용해야 함을 나타냅니다. 이 설정은 다른 컨텍스트에서 실행될 때 VACUUM의 동작에 영향을주지 않습니다.

max_stack_depth (integer)
서버 실행 스택의 최대 안전 깊이를 지정합니다. 이 매개 변수에 대한 이상적인 설정은 커널에 의해 적용되는
실제 스택 크기 제한(ulimit -s 또는 로컬 동등 항목에 의해 설정 됨)이며 안전 여유가 1MB 정도 줄어 듭니다.
스택 깊이는 서버의 모든 루틴에서 확인되지 않고 잠재적으로 반복되는 주요 루틴에서만 확인되기 때문에 안전 여유가 필요합니다.
이 값이 단위없이 지정되면 킬로바이트로 간주됩니다. 기본 설정은 2메가 바이트 (2MB)이며, 이는 보수적으로 작고 충돌 위험이 거의 없습니다.
그러나 복잡한 기능을 실행하기에는 너무 작을 수 있습니다. 수퍼 유저만이 설정을 변경할 수 있습니다.
max_stack_depth를 실제 커널 제한보다 높게 설정하면 런 어웨이(runaway:제어가 안되는) 재귀 함수가 개별 백엔드 프로세스를 충돌시킬 수 있음을 의미합니다.
PostgreSQL이 커널 제한을 결정할 수 있는 플랫폼에서 서버는 이 변수가 안전하지 않은 값으로 설정되는 것을 허용하지 않습니다.
그러나 모든 플랫폼이 정보를 제공하는 것은 아니므로 값을 선택할 때주의하는 것이 좋습니다.

shared_memory_type (enum)
서버가 PostgreSQL의 공유 버퍼 및 기타 공유 데이터를 보유하는 기본 공유 메모리 영역에 사용해야하는 공유 메모리 구현을 지정합니다.
가능한 값은 mmap (mmap을 사용하여 할당된 익명 공유 메모리의 경우), sysv (shmget을 통해 할당된 System V 공유 메모리의 경우) 및 windows (Windows 공유 메모리의 경우)입니다.
모든 플랫폼에서 모든 값이 지원되는 것은 아닙니다. 지원되는 첫 번째 옵션은 해당 플랫폼의 기본값입니다. 어떤 플랫폼에서도 기본값이 아닌 sysv 옵션의 사용은 일반적으로 권장되지 않습니다.
일반적으로 큰 할당을 허용하려면 기본이 아닌 커널 설정이 필요하기 때문입니다.
다음 페이지 참고 : https://www.postgresql.org/docs/12/kernel-resources.html#SYSVIPC

dynamic_shared_memory_type (enum)
서버에서 사용해야 하는 동적 공유 메모리 구현을 지정합니다. 가능한 값은 posix(shm_open을 사용하여 할당된 POSIX 공유 메모리의 경우),
sysv(shmget을 통해 할당된 시스템 V 공유 메모리의 경우), window(윈도우즈 공유 메모리의 경우)
및 mmap(데이터 디렉토리에 저장된 메모리 매핑 파일을 사용하여 공유 메모리를 시뮬레이션하는 경우)입니다.
일부 값이 일부 플랫폼에서 지원되는 것은 아니며, 해당 플랫폼의 기본값이 첫 번째 지원 옵션입니다.
어떤 플랫폼에서도 기본값이 아닌 mmap 옵션은 일반적으로 권장되지 않습니다.
운영 체제가 수정된 페이지를 디스크에 반복적으로 쓰면서 시스템 I/O 로드가 증가할 수 있기 때문입니다. 
그러나 pg_dynshmem 디렉토리가 RAM 디스크에 저장되어 있거나 다른 공유 메모리 기능을 사용할 수없는 경우 디버깅에 유용 할 수 있습니다.


◼︎ Disk
temp_file_limit (integer)
프로세스가 정렬 및 해시 임시 파일과 같은 임시 파일에 사용할 수있는 최대 디스크 공간 또는 보류 커서에 대한 스토리지 파일을 지정합니다.
이 한도를 초과하려는 거래는 취소됩니다. 이 값이 단위없이 지정되면 킬로바이트로 간주됩니다. -1 (기본값)은 제한이 없음을 의미합니다. 수퍼 유저 만이 설정을 변경할 수 있습니다.
이 설정은 주어진 PostgreSQL 프로세스에서 사용하는 모든 임시 파일이 사용하는 총 공간을 제한합니다.
쿼리 실행에서 이면(behind-the-scenes : 보이지 않는 다른면)에서 사용되는 임시 파일과 달리 명시적 임시 테이블에 사용되는 디스크 공간은 이 제한에 포함되지 않습니다.


◼︎ Kernel Resource Usage
각 서버 하위 프로세스에 허용되는 최대 동시 열린 파일 수를 설정합니다. 기본값은 1,000 개의 파일입니다.
커널이 안전한 프로세스당 제한을 적용하는 경우 이 설정에 대해 걱정할 필요가 없습니다.
그러나 일부 플랫폼(특히 대부분의 BSD 시스템)에서 커널은 많은 프로세스가 모두 해당 많은 파일을 열려고 할 때 시스템이 실제로 지원할 수 있는 것보다 더 많은 파일을 개별 프로세스가 열도록 허용합니다.
"열린 파일이 너무 많음"오류가 표시되는 경우 이 설정을 줄여볼 필요가 있습니다. 이 매개 변수는 서버 시작시에만 설정할 수 있습니다.


◼︎ Cost-based Vacuum Delay
VACUUM 및 ANALYZE 명령을 실행하는 동안 시스템은 수행되는 다양한 I/O 작업의 예상 비용을 추적하는 내부 카운터를 유지합니다.
누적 비용이 한도(vacuum_cost_limit로 지정됨)에 도달하면 작업을 수행하는 프로세스가 vacuum_cost_delay에 지정된대로 짧은 시간 동안 휴면 상태가됩니다.
그런 다음 카운터를 재설정하고 실행을 계속합니다. 이 기능의 목적은 관리자가 동시 데이터베이스 활동에 대한 이러한 명령의 I/O 영향을 줄일 수 있도록하는 것입니다.
VACUUM 및 ANALYZE와 같은 유지 관리 명령이 빠르게 완료되는 것이 중요하지 않은 상황이 많이 있습니다.
그러나 일반적으로 이러한 명령이 다른 데이터베이스 작업을 수행하는 시스템의 기능을 크게 방해하지 않는 것이 매우 중요합니다. 비용 기반 진공 지연은 관리자가 이를 달성 할 수 있는 방법을 제공합니다.
이 기능은 수동으로 실행된 VACUUM 명령에 대해 기본적으로 비활성화되어 있습니다. 이를 활성화하려면 vacuum_cost_delay 변수를 0이 아닌 값으로 설정합니다.

vacuum_cost_delay (floating point)
비용 한도를 초과했을 때 프로세스가 휴면하는 시간입니다. 이 값이 단위없이 지정되면 밀리 초로 간주됩니다.
기본값은 0이며 비용 기반 vaccum 지연 기능을 비활성화합니다. 양수 값은 비용 기반 vaccuming 기능을 가능하게합니다.
비용 기반 vacuuming을 사용할 때 vacuum_cost_delay에 대한 적절한 값은 일반적으로 1밀리 초 미만으로 매우 작습니다.
vacuum_cost_delay를 분수 밀리 초(fractional-millisecond) 값으로 설정할 수 있지만 이러한 지연은 이전 플랫폼에서 정확하게 측정되지 않을 수 있습니다.
이러한 플랫폼에서 VACUUM의 제한된 리소스 소비를 1ms에서 얻는것 이상으로 늘리려면 다른 진공 비용 매개 변수를 변경해야합니다. 그럼에도 불구하고 vacuum_cost_delay는 플랫폼이 지속적으로 측정 할 수 있는만큼 작게 유지해야 합니다. 큰 지연은 도움이 되지 않습니다.

vacuum_cost_page_hit (integer)
공유 버퍼 캐시에서 찾은 버퍼를 비우기위한 예상 비용입니다. 버퍼 풀을 잠그고 공유 해시 테이블을 조회하고 페이지의 내용을 스캔하는 비용을 나타냅니다. 기본값은 1입니다.

vacuum_cost_page_miss (integer)
디스크에서 읽어야하는 버퍼를 비우기위한 예상 비용입니다.
이는 버퍼 풀을 잠그고, 공유 해시 테이블을 조회하고, 디스크에서 원하는 블록을 읽고 내용을 스캔하려는 노력을 나타냅니다. 기본값은 10입니다.

vacuum_cost_page_dirty (integer)
vaccum이 이전에 정리된(vaccuming이 필요한 페이지로 표시해둔) 블록을 수정할 때 부과되는 예상 비용입니다.
더티 블록을 디스크로 다시 플러시하는 데 필요한 추가 I / O를 나타냅니다. 기본값은 20입니다.

vacuum_cost_limit (integer)
vaccuming 프로세스를 휴면 상태로 만드는 누적 비용입니다. 기본값은 200입니다.

참고사항
중요한 잠금을 유지하는 특정 작업이 있으므로 가능한 한 빨리 완료해야합니다. 이러한 작업 중에는 비용 기반 vaccum 지연이 발생하지 않습니다.
따라서 비용이 지정된 한도보다 훨씬 더 많이 누적 될 수 있습니다.
이러한 경우 필요없는 긴 지연을 방지하기 위해 실제 지연은 최대 vacuum_cost_delay * 4를 사용하여 vacuum_cost_delay * accumulated_balance / vacuum_cost_limit로 계산됩니다.

◼︎ Background Writer
백그라운드 작성기(Writer)라는 별도의 서버 프로세스가 있으며, 그 기능은 "더티"(새롭거나 수정 된) 공유 버퍼의 쓰기를 실행하는 것입니다.
정리된 공유 버퍼의 수가 충분하지 않은 것처럼 보이면 백그라운드 작성기가 파일 시스템에 일부 더티 버퍼를 쓰고 정리된 것으로 표시합니다.
이렇게 하면 사용자 쿼리를 처리하는 서버 프로세스가 깨끗한 버퍼를 찾지 못하고 더러운 버퍼를 직접 작성해야 할 가능성이 줄어듭니다.
그러나 반복적으로 사용된 페이지(a repeatedly-dirtied page)는 체크 포인트 간격당 한 번만 기록될 수 있지만 백그라운드 기록기는 동일한 간격으로 더러워지므로
여러번 기록할 수 있기 때문에 백그라운드 작성기는 I / O로드를 전체적으로 증가시킵니다. 이 하위 섹션에서 설명하는 매개 변수를 사용하여 로컬 요구에 맞게 동작을 조정할 수 있습니다.

bgwriter_delay (integer)
백그라운드 작성기에 대한 활동 라운드 사이의 지연을 지정합니다. 각 라운드에서 작성기는 일부 더티 버퍼 (다음 매개 변수로 제어 가능)에 대한 쓰기를 발행합니다.
그런 다음 bgwriter_delay의 길이 동안 대기하기를 반복합니다. 그러나 버퍼 풀에 더티 버퍼가 없으면 bgwriter_delay에 관계없이 더 긴 대기상태가 됩니다.
이 값이 단위없이 지정되면 밀리 초로 간주됩니다. 기본값은 200 밀리 초(200ms)입니다. 많은 시스템에서 절전 지연의 효과적인 해결 방법은 10밀리 초입니다.
bgwriter_delay를 10의 배수가 아닌 값으로 설정하면 다음으로 높은 10의 배수로 설정하는 것과 동일한 결과를 얻을 수 있습니다.
이 매개 변수는 postgresql.conf 파일 또는 서버 명령 줄에서만 설정할 수 있습니다.

bgwriter_lru_maxpages (integer)
각 라운드에서 백그라운드 작성자는 이보다 많은 버퍼를 작성하지 않습니다. 0으로 설정하면 백그라운드 쓰기가 비활성화됩니다.
(별도의 전용 보조 프로세스에서 관리하는 체크 포인트는 영향을받지 않습니다.) 기본값은 100 개의 버퍼입니다. 이 매개 변수는 postgresql.conf 파일 또는 서버 명령 줄에서만 설정할 수 있습니다.

bgwriter_lru_multiplier (floating point)
각 라운드에 기록된 더티 버퍼의 수는 최근 라운드 동안 서버 프로세스에 필요한 새 버퍼의 수를 기반으로합니다.
최근 평균 요구량에 bgwriter_lru_multiplier를 곱하여 다음 라운드에서 필요한 버퍼 수를 추정합니다.
더티 버퍼는 사용 가능한 깨끗하고 재사용 가능한 버퍼가 많을 때까지 기록됩니다.(그러나 라운드 당 bgwriter_lru_maxpages 버퍼만 기록됩니다.)
따라서 1.0으로 설정하면 필요할 것으로 예상되는 버퍼 수를 정확히 기록하는 "적시"정책을 나타냅니다.
값이 클수록 수요 급증에 대한 완충 효과가 있는 반면, 값이 작을수록 서버 프로세스에서 쓰기 작업을 의도적으로 남깁니다.
기본값은 2.0입니다. 이 매개 변수는 postgresql.conf 파일 또는 서버 명령 줄에서만 설정할 수 있습니다.

bgwriter_flush_after (integer)
백그라운드 작성자가 현재 데이터의 크기 이상의 데이터를 쓸 때마다 OS가 이러한 쓰기를 기본 스토리지에 실행하도록 강제합니다.
이렇게하면 커널 페이지 캐시의 더티 데이터 양이 제한되어 체크 포인트 끝에서 fsync가 실행되거나 OS가 백그라운드에서 더 큰 일괄 처리로 데이터를 다시 쓸 때 중단될 가능성이 줄어 듭니다.
이로 인해 트랜잭션 지연 시간이 크게 단축되는 경우도 종종 있지만, 특히 shared_buffers보다 크지만 OS 페이지 캐시보다 작은 워크로드가 성능을 저하시킬 수 있는 경우도 있습니다.
이 설정은 일부 플랫폼에 영향을 미치지 않을 수 있습니다. 이 값이 단위없이 지정되면 블록(BLCKSZ 바이트, 일반적으로 8kB)으로 간주됩니다.
유효한 범위는 강제 쓰기 저장을 비활성화하는 0과 2MB 사이입니다. 기본값은 Linux에서 512kB이고 다른 곳에서는 0입니다.
(BLCKSZ가 8kB가 아닌 경우 기본값 및 최대 값은 이에 비례하여 확장됩니다.)이 매개 변수는 postgresql.conf 파일 또는 서버 명령 줄에서만 설정할 수 있습니다.

bgwriter_lru_maxpages 및 bgwriter_lru_multiplier의 값이 작을수록 백그라운드 작성기에서 발생하는 추가 I/O로드가 줄어들지만
서버 프로세스가 자체적으로 쓰기를 실행해야 할 가능성이 높아져 대화형 쿼리가 지연됩니다.

◼︎ Asynchronous Behavior(비동기 활동)
effective_io_concurrency (integer)
PostgreSQL이 동시에 실행할 수 있다고 예상하는 동시 디스크 I/O 작업 수를 설정합니다. 이 값을 높이면 개별 PostgreSQL 세션이 병렬로 시작하려고 시도하는 I/O 작업 수가 증가합니다.
허용 범위는 1에서 1000까지, 또는 비동기 I/O 요청의 발행을 비활성화 하려면 0입니다. 현재 이 설정은 비트맵 힙 스캔(bitmap heap scan)에만 영향을줍니다.
마그네틱 드라이브의 경우 이 설정의 좋은 시작점은 데이터베이스에 사용되는 RAID 0의 스트라이프 방식 또는 RAID 1의 미러 방식으로 구성된 개별 드라이브의 수입니다.
(RAID 5의 경우 패리티 드라이브는 계산되지 않습니다.) 그러나 데이터베이스가 종종 동시 세션에서 실행된 여러 쿼리로 사용중이면 디스크 어레이를 사용하기 위해 더 낮은 값으로 충분할 수 있습니다.
디스크의 성능을  유지하는데 필요한 값보다 큰 값은 추가 CPU 오버 헤드만 발생시킵니다.
SSD 및 기타 메모리 기반 스토리지는 종종 많은 동시 요청을 처리할 수 ​​있으므로 최상의 가치는 수백 개일 수 있습니다.
비동기 I/O는 일부 운영 체제에없는 효과적인 posix_fadvise 함수에 의존합니다. 함수가 없는 경우 이 매개 변수를 0이외의 값으로 설정하면 오류가 발생합니다.
일부 운영 체제 (예 : Solaris)에서는 기능이 있지만 실제로는 아무 작업도 수행하지 않습니다.
지원되는 시스템에서 기본값은 1이고 그렇지 않으면 0입니다. 같은 이름의 테이블 스페이스 매개 변수를 설정하여 특정 테이블 스페이스의 테이블에 대해 이 값을 재정의 할 수 있습니다(ALTER TABLESPACE 참조).

max_worker_processes (integer)
시스템이 지원할 수있는 최대 백그라운드 프로세스 수를 설정합니다. 이 매개 변수는 서버 시작시에만 설정할 수 있습니다. 기본값은 8입니다.
대기 서버를 실행할 때 이 매개 변수를 마스터 서버와 같거나 더 높은 값으로 설정해야 합니다. 그렇지 않으면 대기 서버에서 쿼리가 허용되지 않습니다.
이 값을 변경할 때 max_parallel_workers, max_parallel_maintenance_workers 및 max_parallel_workers_per_gather도 조정하는 것이 좋습니다.

max_parallel_workers_per_gather (integer)
단일 Gather 또는 Gather Merge 노드에서 시작할 수있는 최대 작업자(worker) 수를 설정합니다.
병렬 작업자는 max_parallel_workers에 의해 제한되는 max_worker_processes에 의해 설정된 프로세스 풀에서 가져옵니다.
요청된 작업자 수는 실제로 런타임에 사용 가능하지 않을 수 있습니다. 이 경우 계획은 예상보다 적은 수의 작업자로 실행되므로 비효율적일 수 있습니다.
기본값은 2입니다. 이 값을 0으로 설정하면 병렬 쿼리 실행이 비활성화 됩니다.
병렬 쿼리는 비 병렬 쿼리보다 훨씬 더 많은 리소스를 소비할 수 있습니다. 각 작업자 프로세스는 시스템에 추가 사용자 세션과 거의 동일한 영향을 미치는 완전히 별개의 프로세스이기 때문입니다.
이 설정에 대한 값을 선택할 때뿐만 아니라 work_mem과 같이 리소스 사용률을 제어하는 ​​다른 설정을 구성할 때도 이 점을 고려해야합니다.
work_mem과 같은 리소스 제한은 각 작업자에게 개별적으로 적용됩니다. 즉, 전체 사용률은 일반적으로 단일 프로세스보다 훨씬 높을 수 있습니다.
예를 들어 4명의 작업자를 사용하는 병렬 쿼리는 작업자를 전혀 사용하지 않는 쿼리로 CPU 시간, 메모리, I/O 대역폭 등을 최대 5 배까지 사용할 수 있습니다.
병렬 쿼리에 대한 자세한 내용은 15 장을 참조하십시오.(https://www.postgresql.org/docs/12/parallel-query.html)

max_parallel_maintenance_workers (integer)
단일 유틸리티 명령으로 시작할 수있는 최대 병렬 작업자 수를 설정합니다. 현재 병렬 워커 사용을 지원하는 유일한 병렬 유틸리티 명령은 CREATE INDEX이며 B-트리 인덱스를 빌드  때만 가능합니다.
병렬 작업자는 max_parallel_workers에 의해 제한되는 max_worker_processes에 의해 설정된 프로세스 풀에서 가져옵니다.
요청된 작업자 수는 실제로 런타임에 사용 가능하지 않을 수 있습니다. 이 경우 유틸리티 작업이 예상보다 적은 수의 작업자로 실행됩니다.
기본값은 2입니다.이 값을 0으로 설정하면 유틸리티 명령에서 병렬 작업자를 사용할 수 없습니다.
병렬 유틸리티 명령은 동등한 비 병렬 작업보다 훨씬 많은 메모리를 소비해서는 안됩니다. 이 전략은 일반적으로 작업자 프로세스 당 리소스 제한이 적용되는 병렬 쿼리의 전략과 다릅니다.
병렬 유틸리티 명령은 자원 제한 maintenance_work_mem을 병렬 작업자 프로세스 수에 관계없이 전체 유틸리티 명령에 적용 할 제한으로 취급합니다.
그러나 병렬 유틸리티 명령은 여전히 ​​훨씬 더 많은 CPU 리소스와 I/O 대역폭을 소비 할 수 있습니다.

max_parallel_workers (integer)
시스템이 병렬 작업을 지원할 수있는 최대 작업자(worker) 수를 설정합니다. 기본값은 8입니다.
이 값을 늘리거나 줄일 때 max_parallel_maintenance_workers 및 max_parallel_workers_per_gather도 조정하는 것이 좋습니다.
또한 max_worker_processes보다 높은 이 값에 대한 설정은 해당 설정에 의해 설정된 작업자 프로세스 풀에서 병렬 작업자를 가져 오기 때문에 영향을주지 않습니다.

backend_flush_after (integer)
단일 백엔드에서 일정크기 이상의 데이터를 쓸 때마다 OS가 이러한 쓰기를 기본 스토리지에 실행하도록 강제합니다.
이렇게 하면 커널 페이지 캐시의 더티 데이터 양이 제한되어 체크 포인트 끝에서 fsync가 실행되거나 OS가 백그라운드에서 더 큰 일괄 처리로 데이터를 다시 쓸 때 중단될 가능성이 줄어 듭니다.
이는 종종 트랜잭션 지연 시간을 크게 줄이지만, 특히 shared_buffers보다 크지만 OS의 페이지 캐시보다 작은 워크로드의 경우 성능이 저하될 수 있는 경우도 있습니다.
이 설정은 일부 플랫폼에 영향을 미치지 않을 수 있습니다. 이 값이 단위없이 지정되면 블록 (BLCKSZ 바이트, 일반적으로 8kB)으로 간주됩니다.
유효한 범위는 강제 쓰기 저장을 비활성화하는 0과 2MB 사이입니다. 기본값은 0입니다. 즉, 강제 쓰기 저장이 없습니다. (BLCKSZ가 8kB가 아닌 경우 최대 값은 이에 비례하여 조정됩니다.)

old_snapshot_threshold (integer)
스냅샷을 사용할 때 "snapshot too old(스냅 샷이 너무 오래됨)" 오류가 발생할 위험없이 쿼리 스냅샷을 사용할 수 있는 최소 시간을 설정합니다.
이 임계 값보다 오랫동안 죽은 데이터는 진공 처리할 수 ​​있습니다. 이렇게 하면 오랫동안 사용중인 스냅샷에 대한 팽창을 방지할 수 있습니다.
그렇지 않으면 스냅샷에 표시되는 데이터 정리로 인한 잘못된 결과를 방지하기 위해 스냅샷이이 임계 값보다 오래된 경우 오류가 생성되고 스냅샷이 빌드된 이후 수정된 페이지를 읽는데 스냅샷이 사용됩니다.
이 값이 단위없이 지정되면 분으로 간주됩니다. -1 (기본값)값은 이 기능을 비활성화하여 스냅샷 보존 기간을 무한대로 효과적으로 설정합니다. 이 매개 변수는 서버 시작시에만 설정할 수 있습니다.
생산 작업에 유용한 값은 아마도 몇 시간에서 며칠까지 다양합니다. 작은 값(예 : 0 또는 1 분)은 때때로 테스트에 유용할 수 있으므로 허용됩니다.
60d까지 설정이 허용되지만 많은 워크로드에서 극단적인 팽창 또는 트랜잭션 ID랩 어라운드가 훨씬 더 짧은 시간 프레임에서 발생할 수 있습니다.
이 기능이 활성화되면 "snapshot too old(스냅 샷이 너무 오래됨)"상태를 감지하는데 필요한 정보가 제거될 수 있으므로 관계 끝에 있는 여유 공간을 운영체제로 해제할 수 없습니다.
관계에 할당 된 모든 공간은 명시적으로 해제되지 않는 한 (예 : VACUUM FULL 사용) 해당 관계 내에서만 재사용을 위해 해당 관계와 연결되어 있습니다.
이 설정은 특정 상황에서 오류가 생성되는 것을 보장하지 않습니다.
실제로 결과 세트를 구체화한 커서 (예 : 커서)에서 올바른 결과를 생성할 수 있는 경우, 참조된 테이블의 기본 행이 제거된 경우에도 오류가 생성되지 않습니다.
일부 테이블은 조기에 안전하게 비울 수 없으므로 시스템 카탈로그와 같은 이 설정의 영향을 받지 않습니다.
이러한 테이블의 경우 이 설정은 스캔시 팽창을 줄이거 나 "snapshot too old(스냅 샷이 너무 오래됨)"오류 가능성을 생성하지 않습니다.
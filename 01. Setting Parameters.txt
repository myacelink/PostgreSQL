◼︎ 매개 변수 이름 및 값
모든 파라미터 이름은 대소문자를 구분하지 않습니다. 모든 매개 변수는 부울, 문자열, 정수, 부동 소수점 또는 열거(enum) 유형중 하나의 값을 갖습니다.
유형은 매개 변수 설정 구문을 결정합니다.

* boolean(부울) : 값은 on, off, true, false, yes, no, 1, 0 (모두 대소 문자 구분 안 함) 또는 이들 중 하나의 명확한 접두어로 작성될 수 있습니다.

* 문자열 : 일반적으로 값을 작은 따옴표로 묶고 값 내의 작은 따옴표를 두 배로 늘립니다. 그러나 값이 단순한 숫자 또는 식별자인 경우 일반적으로 따옴표를 생략 할 수 있습니다.
(SQL 키워드와 일치하는 값은 일부 컨텍스트에서 따옴표가 필요합니다.)

* 숫자 (정수 및 부동 소수점) : 숫자 매개 변수는 일반적인 정수 및 부동 소수점 형식으로 지정할 수 있습니다. 매개 변수가 정수 유형인 경우 분수 값은 가장 가까운 정수로 반올림됩니다.
정수 매개 변수는 추가로 16 진수 입력(0x로 시작) 및 8진수 입력 (0으로 시작)을 허용하지만 이러한 형식은 분수를 가질 수 없습니다. 천 단위 구분 기호를 사용하지 마십시오.
16 진수 입력을 제외하고는 따옴표가 필요하지 않습니다.

* 단위가 있는 숫자 : 일부 숫자 매개 변수는 메모리 또는 시간의 양을 설명하기 때문에 암시적 단위를 갖습니다. 단위는 바이트, 킬로바이트, 블록 (일반적으로 8 킬로바이트),
밀리초, 초 또는 분일 수 있습니다. 이러한 설정중 하나에 대한 장식되지 않은 숫자 값은 pg_settings.unit에서 학습 할 수 있는 설정의 기본 단위를 사용합니다.
편의상 설정은 명시적으로 지정된 단위 (예 : 시간 값으로 '120ms')로 지정할 수 있으며 매개 변수의 실제 단위가 무엇이든 변환됩니다.
이 기능을 사용하려면 값을 문자열(따옴표 포함)로 작성해야 합니다. 단위 이름은 대소 문자를 구분하며 숫자 값과 단위 사이에 공백이 있을 수 있습니다.
1. 유효한 메모리 단위는 B (바이트), kB (킬로바이트), MB (메가 바이트), GB (기가 바이트) 및 TB (테라 바이트)입니다. 메모리 단위의 승수는 1000이 아니라 1024입니다.
2. 유효한 시간 단위는 us(마이크로 초), ms(밀리 초), s(초), min(분), h(시간) 및 d(일)입니다.
분수 값이 단위와 함께 지정되면 다음으로 작은 단위가 있으면 그 다음으로 작은 단위의 배수로 반올림됩니다. 예를 들어, 30.1GB는 32319628902 B가 아닌 30822MB로 변환됩니다.
매개 변수가 정수 유형이면 단위 변환 후 정수로의 최종 반올림이 발생합니다.

* 열거형(enumerated type) : 열거형 매개 변수는 문자열 매개 변수와 동일한 방식으로 작성되지만 제한된 값 집합중 하나를 갖도록 제한됩니다.
이러한 매개 변수에 허용되는 값은 pg_settings.enumvals에서 찾을 수 있습니다. Enum 매개 변수 값은 대소 문자를 구분하지 않습니다.

◼︎ 구성(Configuration) 파일을 통한 매개 변수 상호 작용
이러한 매개 변수를 설정하는 가장 기본적인 방법은 일반적으로 데이터 디렉토리에 보관되는 postgresql.conf 파일을 편집하는 것입니다.
데이터베이스 클러스터 디렉토리가 초기화되면 기본 사본이 설치됩니다. 이 파일의 예는 다음과 같습니다.

# Comment
log_connections = yes
log_destination = 'syslog'
search_path = '"$user", public'
shared_buffers = 128MB

한 줄에 하나의 매개 변수가 지정됩니다. 이름과 값 사이의 등호는 선택 사항입니다. 공백은 중요하지 않으며 (따옴표로 묶인 파라미터 값 내 제외) 빈 줄은 무시됩니다.
해시 표시(#)는  해당라인의 커서 부분에서 나머지 뒷부분을 주석으로 지정합니다.(전체가 아니라 해당 라인입니다.) 단순 식별자 또는 숫자가 아닌 매개변수 값은 작은 따옴표로 묶어야합니다.
파라미터 값에 작은 따옴표를 포함하려면 두 개의 따옴표(권장) 또는 백 슬래시-따옴표를 작성합니다.
파일에 동일한 매개 변수에 대한 여러 항목이 포함된 경우 마지막 항목을 제외한 모든 항목이 무시됩니다.

이 방법으로 설정된 파라미터는 클러스터에 대한 기본값을 제공합니다. 활성 세션에 표시되는 설정은 재정의되지 않는 한 이러한 값이 됩니다.
다음 섹션에서는 관리자 또는 사용자가 이러한 기본값을 재정의 할 수 있는 방법에 대해 설명합니다.

주 서버 프로세스가 SIGHUP 신호를 수신할 때마다 구성 파일을 다시 읽습니다.
이 신호는 명령 줄에서 pg_ctl reload를 실행하거나 SQL 함수 pg_reload_conf()를 호출하여 가장 쉽게 전송됩니다.
주 서버 프로세스는 또한 현재 실행중인 모든 서버 프로세스에 이 신호를 전파하므로 기존 세션도 새 값을 채택합니다 (현재 실행중인 클라이언트 명령을 완료 한 후에 발생 함).
또는 신호를 단일 서버 프로세스로 직접 보낼 수 있습니다. 일부 매개 변수는 서버 시작시에만 설정할 수 있습니다.
구성 파일의 항목에 대한 변경 사항은 서버가 다시 시작될 때까지 무시됩니다. 구성 파일의 유효하지 않은 매개 변수 설정은 SIGHUP 처리 중에 마찬가지로 무시되지만 기록됩니다.

postgresql.conf 외에도 PostgreSQL 데이터 디렉토리에는 postgresql.conf와 형식이 같지만 수동이 아닌 자동으로 편집되는 postgresql.auto.conf 파일이 포함되어 있습니다.
이 파일은 ALTER SYSTEM 명령을 통해 제공된 설정을 보유합니다. 이 파일은 postgresql.conf가있을 때마다 읽 히며 해당 설정은 동일한 방식으로 적용됩니다.
postgresql.auto.conf의 설정은 postgresql.conf의 설정보다 우선합니다.

외부 도구는 postgresql.auto.conf를 수정할 수도 있습니다.
동시 ALTER SYSTEM 명령이 이러한 변경 사항을 덮어 쓸 수 있으므로 서버가 실행되는 동안에는 이 작업을 수행하지 않는 것이 좋습니다.
이러한 도구는 단순히 새 설정을 끝에 추가하거나 중복 설정 또는 주석을 제거하도록 선택할 수 있습니다 (ALTER SYSTEM이 수행하는 것처럼).

시스템 뷰 pg_file_settings는 구성 파일의 변경 사항을 사전 테스트하거나 SIGHUP 신호가 원하는 효과를 얻지 못한 경우 문제를 진단하는 데 유용할 수 있습니다.

◼︎ SQL을 통한 매개 변수 상호 작용
PostgreSQL은 구성 기본값을 설정하는 세가지 SQL 명령을 제공합니다. 이미 언급한 ALTER SYSTEM 명령은 전역 기본값을 변경하는 SQL액세스 방법을 제공합니다.
postgresql.conf를 편집하는 것과 기능적으로 동일합니다. 또한 데이터베이스 또는 역할별로 기본값을 설정할 수 있는 두 가지 명령이 있습니다.

* ALTER DATABASE 명령을 사용하면 데이터베이스별로 전역 설정을 재정의 할 수 있습니다.

* ALTER ROLE 명령을 사용하면 전역 및 데이터베이스별 설정을 모두 사용자별 값으로 재정의 할 수 있습니다.

ALTER DATABASE 및 ALTER ROLE로 설정된 값은 새 데이터베이스 세션을 시작할 때만 적용됩니다.
구성 파일 또는 서버 명령 줄에서 얻은 값을 재정의하고 나머지 세션에 대한 기본값을 구성합니다. 일부 설정은 서버 시작 후 변경할 수 없으므로 이러한 명령(또는 아래 나열된 명령)으로 설정할 수 없습니다.

클라이언트가 데이터베이스에 연결되면 PostgreSQL은 세션 로컬 구성 설정과 상호 작용하는 두 가지 추가 SQL명령(그리고 동등한 기능들)을 제공합니다.
* SHOW 명령은 모든 매개 변수의 현재 값을 검사할 수 있습니다. 해당 기능은 current_setting (setting_name text)입니다.
* SET 명령을 사용하면 세션에 로컬로 설정할 수 있는 해당 매개 변수의 현재 값을 수정할 수 있습니다. 다른 세션에는 영향을주지 않습니다.
해당 함수는 set_config (setting_name, new_value, is_local)입니다.

또한 시스템 뷰 pg_settings를 사용하여 세션 로컬 값을보고 변경할 수 있습니다.
*이 뷰를 쿼리하는 것은 SHOW ALL을 사용하는 것과 비슷하지만 더 자세한 정보를 제공합니다. 필터 조건을 지정하거나 다른 관계에 대해 조인할 수 있기 때문에 더 유연합니다.
*이 뷰에서 UPDATE를 사용하는 것, 특히 설정 컬럼을 업데이트하는 것은 SET 명령을 실행하는 것과 같습니다. 예를 들어,
SET configuration_parameter TO DEFAULT;

이것은
UPDATE pg_settings SET setting = reset_val WHERE name = 'configuration_parameter';


◼︎ 쉘을 통한 매개 변수 상호 작용
전역 기본값을 설정하거나 데이터베이스 또는 역할 수준에서 재정의를 연결하는 것 외에도 셸 기능을 통해 PostgreSQL에 설정을 전달할 수 있습니다.
서버 및 libpq 클라이언트 라이브러리 모두 셸을 통해 파라미터 값을 허용합니다.

* 서버 시작 중에 파라미터 설정은 -c 명령 줄 매개 변수를 통해 postgres 명령으로 전달할 수 있습니다. 예를 들면
postgres -c log_connections=yes -c log_destination='syslog'

이러한 방식으로 제공되는 설정은 postgresql.conf 또는 ALTER SYSTEM을 통해 설정된 설정보다 우선하므로 서버를 다시 시작하지 않고는 전역적으로 변경할 수 없습니다.

* libpq를 통해 클라이언트 세션을 시작할 때 PGOPTIONS 환경 변수를 사용하여 매개 변수 설정을 지정할 수 있습니다.
이러한 방식으로 설정된 설정은 세션이 유지되는 상태에서만 기본값을 구성하지만 다른 세션에는 영향을주지 않습니다.
여러 히스토리적인 이유로 PGOPTIONS의 형식은 postgres 명령을 시작할 때 사용되는 형식과 유사합니다. 특히, -c 플래그를 지정해야합니다.
예를 들면
env PGOPTIONS="-c geqo=off -c statement_timeout=5min" psql

다른 클라이언트와 라이브러리는 사용자가 SQL명령을 직접 사용하지 않고 세션 설정을 변경할 수 있도록 셸 또는 기타를 통해 자체 메커니즘을 제공할 수 있습니다.

◼︎ 구성 파일 내용 관리
PostgreSQL은 복잡한 postgresql.conf 파일을 하위 파일로 분해하기 위한 여러 기능을 제공합니다.
이러한 기능은 관련이 있지만 동일하지는 않은 구성으로 여러 서버를 관리할 때 특히 유용합니다.

개별 매개 변수 설정 외에도 postgresql.conf 파일에는 이 시점에서 구성 파일에 삽입된 것처럼 읽고 처리할 다른 파일을 지정하는 include 지시문이 포함될 수 있습니다.
이 기능을 사용하면 구성 파일을 물리적으로 분리된 부분으로 나눌 수 있습니다. Include 지시문은 다음과 같습니다.
include 'filename'

파일 이름이 절대경로가 아닌 경우, 참조하는 구성 파일이 포함된 디렉토리에 상대적인 것으로 간주됩니다. 포함은 중첩될 수 있습니다.

참조된 파일이 존재하지 않거나 읽을 수 없는 경우를 제외하고 include 지시문과 동일하게 작동하는 include_if_exists 지시문도 있습니다.
일반 포함은 이를 오류 조건으로 간주하지만 include_if_exists는 메시지를 기록하고 참조 구성 파일을 계속 처리합니다.

postgresql.conf 파일에는 포함할 구성 파일의 전체 디렉토리를 지정하는 include_dir 지시문도 포함될 수 있습니다. 사용법은 다음과 같습니다.
include_dir 'directory'

절대적이지 않은 디렉토리(Non-absolute directory) 이름은 참조하는 구성 파일을 포함하는 디렉토리에 상대적인 것으로 간주됩니다.
지정된 디렉토리 내에 이름이 접미사 .conf로 끝나는 비 디렉토리 파일만 포함됩니다. 일부 플랫폼에서는 이러한 파일이 숨겨져 있으므로 실수를 방지하기 위해 문자도 무시됩니다.
포함 디렉토리 내의 여러 파일은 파일이름 순서로 처리됩니다 (C 로케일 규칙, 즉 문자앞의 숫자 및 소문자 앞의 대문자).

파일을 포함하거나 또는 디렉토리를 사용하여 하나의 큰 postgresql.conf 파일을 갖는 대신 데이터베이스 구성의 일부를 논리적으로 분리할 수 ​​있습니다.
각각 다른 양의 메모리를 가진 두개의 데이터베이스 서버가 있는 회사가 있다고 가정합니다. 로깅과 같은 것을 위해 둘 다 공유할 구성 요소가 있을 수 있습니다.
그러나 서버의 메모리 관련 매개 변수는 둘 사이에서 다릅니다. 서버별 사용자 지정도 있을 수 있습니다.
이 상황을 관리하는 한 가지 방법은 사이트에 대한 사용자 지정 구성 변경 사항을 세 개의 파일로 나누는 것입니다. postgresql.conf 파일 끝에 다음을 추가하여 포함할 수 있습니다.
include 'shared.conf'
include 'memory.conf'
include 'server.conf'

모든 시스템은 동일한 shared.conf를 갖습니다. 특정 양의 메모리를 가진 각 서버는 동일한 memory.conf를 공유할 수 있습니다.
8GB RAM이 있는 모든 서버에 대해 하나, 16GB가 있는 서버에 대해 하나가 있을 수 있습니다. 마지막으로 server.conf에는 서버별 구성 정보가 포함될 수 있습니다.

또 다른 가능성은 구성 파일 디렉토리를 만들고 이 정보를 파일에 넣는 것입니다.
예를 들어 conf.d 디렉토리는 postgresql.conf의 끝에서 참조할 수 있습니다.
include_dir 'conf.d'

그런 다음 conf.d 디렉토리의 파일 이름을 다음과 같이 지정할 수 있습니다.
00shared.conf
01memory.conf
02server.conf

이 명명 규칙은 이러한 파일이 로드되는 명확한 순서를 설정합니다. 이는 서버가 구성 파일을 읽는 동안 특정 매개 변수에 대해 발생한 마지막 설정만 사용되기 때문에 중요합니다.
이 예에서 conf.d/02server.conf에 설정된 항목은 conf.d/01memory.conf에 설정된 값을 재정의 합니다.

대신 이 방법을 사용하여 파일 이름으로 설명이 가능하도록 지정할 수 있습니다.
00shared.conf
01memory-8GB.conf
02server-foo.conf

이러한 종류의 배열은 각 구성 파일 변형에 대해 고유한 이름을 제공합니다.
이렇게 하면 여러 서버의 구성이 모두 버전 제어 저장소와 같은 한 위치에 저장되어 있을때 모호함을 제거하는 데 도움이됩니다.
(버전 제어하에 데이터베이스 구성 파일을 저장하는 것도 고려해야할 또 다른 좋은 방법입니다.)